%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Based on a TeXnicCenter-Template, which was             %%
%% created by Christoph Börensen                           %%
%% and slightly modified by Tino Weinkauf.                 %%
%%                                                         %%
%% Then, a third guy - me - put in some modifications.     %%
%%                                                         %%
%% IFT2245 - Rapport TP1                                   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,12pt]{scrartcl}
% Optimised for letter. Add ",twosides" to use the two-sides layout.

% Margins
    \usepackage{vmargin}
    \setpapersize{USletter}
    \setmargins{2.0cm}%	 % Left edge
               {1.5cm}%  % Top edge
               {17.7cm}% % Text width
               {21.0cm}% % Text height
               {14pt}%	 % Header height
               {1cm}%    % Header distance
               {0pt}%	 % Footer height
               {2cm}%    % Footer distance
				
% Graphical bugfix (about footnotes)
    \usepackage[bottom]{footmisc}

% Fonts and locale
	\usepackage{t1enc}
	\usepackage[utf8]{inputenc}
	\usepackage{times}
	\usepackage[francais]{babel}
	\usepackage{amsmath}

	\AtBeginDocument {%
	    \renewcommand\tablename{\textsc{Tableau}}
	}

% Graphics
	\usepackage[pdftex]{graphicx}
	\usepackage{color}
	\usepackage{eso-pic}
	\usepackage{everyshi}
	\renewcommand{\floatpagefraction}{0.7}

% Enable hyperlinks
	\usepackage[pdfborder=000,pdftex=true]{hyperref}
	
% Table layout
	\usepackage{booktabs}

% Caption
	\usepackage{ccaption}
	\captionnamefont{\bf\footnotesize\sffamily}
	\captiontitlefont{\footnotesize\sffamily}
	\setlength{\abovecaptionskip}{0mm}

% Header and footer settings
	\usepackage{scrpage2} 
	\renewcommand{\headfont}{\footnotesize\sffamily}
	\renewcommand{\pnumfont}{\footnotesize\sffamily}

% Pagestyles
	\defpagestyle{cb}{
		(\textwidth,0pt) % Sets the border line above the header
		{\pagemark\hfill\headmark\hfill} % Doublesided, left page
		{\hfill\headmark\hfill\pagemark} % Doublesided, right page
		{\hfill\headmark\hfill\pagemark} % Onesided
		(\textwidth,1pt)} % Sets the border line below the header
		{(\textwidth,1pt) % Sets the border line above the footer
		{{\it Rapport TP1 (IFT2245)}\hfill Sulliman Aïad et François Poitras} % Doublesided, left page
		{Charles Langlois et François Poitras\hfill{\it Rapport TP1 (IFT2245)}} % Doublesided, right page
		{Charles Langlois et François Poitras\hfill{\it Rapport TP1 (IFT2245)}} % One sided printing
		(\textwidth,0pt) % Sets the border line below the footer
	}

% Empty pages style
	\renewpagestyle{plain}
		{(\textwidth,0pt)
			{\hfill}{\hfill}{\hfill}
		(\textwidth,0pt)}
		{(\textwidth,0pt)
			{\hfill}{\hfill}{\hfill}
		(\textwidth,0pt)}

% Footnotes
	\renewcommand{\footnoterule}{\rule{5cm}{0.2mm} \vspace{0.3cm}}
	\deffootnote[1em]{1em}{1em}{\textsuperscript{\normalfont\thefootnotemark}}

\pagestyle{plain}

\begin{document}
	\begin{center}
		\vspace{2cm}

		{\Huge\bf\sf Rapport du Travail Pratique 1}

		\vspace{0.5cm}

		{\bf\sf (TP1)}

		\vspace{4cm}

		{\bf\sf Par}

		\vspace{0.5cm}{\large\bf\sf Charles Langlois et François Poitras}

		\vspace{2cm}

		{\bf\sf Rapport présenté à}

		\vspace{0.5cm}{\large\bf\sf M. Stefan Monnier}

		\vspace{2cm}

		{\bf\sf Dans le cadre du cours de}

		\vspace{0.5cm}{\large\bf\sf Systèmes d'exploitation (IFT2245)}

		\vspace{\fill}
		\today

		\vspace{0.5cm}Université de Montréal
	\end{center}
	
	\newpage

	\pagestyle{cb}
	
	\tableofcontents

	\newpage

	\section{Fonctionnement du shell}
			Le programme démarre en affichant le répertoire de travail courant, qui correspond au répertoire où le programme \textit{ch} est situé. À partir de ce point, toutes les commandes disponibles qui sont définies dans la variable d'environnement \textit{PATH} peuvent êtres éxecutées, avec leurs arguments respectifs. Il est aussi possible de rediriger la sortie ou l'entrée d'une commande en utilisant le symbole '>' ou '<', comme dans la plupart des terminaux sous Linux. De la même façon, l'usager peut utliser des \textit{pipes} avec le symbole '|' et enchainer plusieurs commandes avec des point-virgule pour séparer les instructions.

			Il est possible d'utiliser une astérisque pour faire référence à tous les fichiers normaux dans le répertoire courant. Les fichiers normaux sont ceux qui ne commencent par par un point et ceux qui ne sont pas '.' ou '..'. Par exemple, la commande \textit{echo *} affichera le nom de tous les fichiers du répertoire courant. Entre deux entrées, l'utilisateur peut quitter le programme en utilisant la commande \textit{quit} ou encore en utilisant CTRL-D.

		\subsection{Traitement de l'entrée}
			Notre shell commence par éliminer tous les espace au début de la commande, s'il y en a. Ensuite, on lit charactère par charactère dans un buffer jusqu'à ce qu'un caractère spécial soit atteint. La fonction \textit{strmem} permet de détecter si une chaîne comporte un charactère spécial. Ces charactères sont le retour à la ligne, les opérateurs de redirection, de pipe, un espace, un point-virgule ou la fin du fichier (\textit{EOF}). Lorsqu'un de ces évènements se produit, on regarde avec un \textit{switch} quel évènement s'est produit et on ajuste les sorties et entrées en conséquence. Par exemple, dans le cas où on a un '>', la sortie est un fichier spécifié et l'entrée est \textit{stdin}. Si la commande n'est pas \textit{quit} et que la syntaxe de la commande semble valide, la fonction \textit{execCommand} est appelée avec les arguments qui correspondent à ce qui a été entré et les \textit{file descriptors} correctement ajustés. À partir de ce point, deux scénarios peuvent se produire. Soit l'utilisateur a entré une commande externe, soit il a entré une commande interne. Une fois le travail effectué, la mémoire allouée par les appels à \textit{strdup} est libérée et le programme attends la prochaine commande. 
			
			\subsubsection{Commandes externes}
			L'argument \textit{args} passé à la fonction \textit{execCommand} est un tableau de chaînes de charactères. Autrement dit, un \textit{char**}. \textit{args[0]} correspond a la commande entrée. Il faut donc vérifier le contenu de cette case. En particulier, il faut vérifier s'il y a un contenu. Si il y a un contenu, on vérifie s'il s'agit de 'cd'. Si oui, la fonction du même nom est appelée et gère le changement de dossier. Nous sommes maintenants arrivés au cas où l'utilisateur cherche à exécuter un programme externe. Le processus doit donc être dupliqué à l'aide de \textit{fork()}.

			Par la suite, une vérification du \textit{PID} doit être faite pour permettre de savoir si le code suivant est exécuté dans le processus enfant ou parent. Si on est dans l'enfant, on vérifie les \textit{file descriptors} passés en argument et on appelle \textit{execvp} pour rouler le programme. L'utilisation particulière de cette commande permet d'éviter de gèrer la variable d'environnement \textit{PATH}, en raison du suffixe 'p'. De plus, la famille de fonctions \textit{exec} qui comporte un 'v' en suffixe demande de recevoir un \textit{char**} en guise d'arguments aux programmes externes. Comme c'est ce que nous passons en argument à notre fonction, nous n'avons aucun traitement particulier à faire. Dans le cas où l'exécution est dans le processus parent, il s'agit simplement d'attendre que le processus enfant termine et de retourner le status de l'enfant, s'il y a lieu.

			\subsubsection{Commandes internes}
				Par manque de temps, les seules commandes internes qui sont gérées par notre shell sont 'cd' et 'quit'. La deuxième ayant été expliquée plus haut, nous allons ici décrire le comportement de la première. 'cd' se comporte comme nous sommes habitués, à l'exception de la gestion du '~'. En effet, il est possible de faire 'cd' et toutes ses variations définies dans la plupart des terminaux Linux, mais les variations comme \textit{cd ~/machin} ne sont pas gérées. Il est possible d'utiliser \textit{cd -} pour revenir au dernier dossier visité. Évidemment, si il n'y a pas de dossier précédent, la commande va se comporter comme si l'utilisateur voulait accéder à un dossier nommé '-'.

		\subsection{Gestion des erreurs}
			Les messages d'erreurs sont des citations inspirées de Margaret Tatcher. Même si cela peut paraître ridicule, les messages
		d'erreurs sont quand même descriptifs du problème qui c'est produit. On arrive sans problème à comprendre ce qui c'est passé. Par exemple, si on entre une commande qui n'existe pas, le shell nous répondra «There's no such thing as <command>. Only families and individuals.» où <command> sera le nom de la commande entrée. D'autres messages sont générés si l'utilisateur tente d'accèder à un endroit sur le disque où il n'a pas accès, ou encore si la commande entrée est trop grande. 

	\section{Problèmes rencontrés}
		Puisque nous parlons de programmation en C, l'un des principaux problèmes est bien évidemment la gestion manuelle de la mémoire. Les \textit{segmentation fault} furent nombreux au cours du développement et parfois subtils à règler. En particulier, l'expansion d'arguments a posé problème car il fallait trouver comment remplacer en mémoire l'astérisque par tous les fichiers normaux présents dans le répertoire courant. Le remplacement direct n'était pas une possibilité, car la longueur de l'astérisque est évidemment inférieure à la longueur des noms des fichiers et un remplacement direct cause un \textit{buffer overflow}. Pour règler le problème, nous avons utilisé \textit{realloc}, en tenant compte du nombre de fichiers présents dans le répertoire. 

		L'autre problème concerne notre connaissance des fonctions POSIX. En effet, comme nous n'étions pas habitués à ces fonctions, nous avons été ralentis par le fait de devoir nous documenter sur leur fonctionnement. Dans les premières versions de notre code, nous ne connaissions pas l'existence de toutes les fonctions de la famille \textit{exec} et nous avions commencé à développer des fonctions pour \textit{parser} le contenu de la variable d'environnement \textit{PATH}. Nous avons compris comment utiliser les fonctions de gestions de \textit{file descriptors} d'une façon similaire, en consultant les pages de manuel des fonctions appropriées. Nous avons aussi eu recours à StackOverflow pour la compréhension des fonctions de gestion des répertoires. Ces fonctions se sont toutefois avérées très simples à utiliser.
\end{document}